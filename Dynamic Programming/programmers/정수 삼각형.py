# Input
# triangle = 삼각형 정보가 담긴 배열 (삼각형 높이 1 ~ 500) (삼각형 숫자 0 ~ 9999)
# Output
# 삼각형 꼭대기에서 바닥까지 이어지는 경로 중 거쳐간 숫자의 최댓값
# 아래칸 이동 시 대각선 방향으로 한 칸 오른쪽 또는 왼쪽
# Hint
# Brtue Force + DFS? = 문제는 높이가 500…. 이는 방문할 수 있는 모든 경로의 경우의 수는 2^{500} 가지…
# 결국 모든 경로를 확인해야 하는데, 한 경로만을 끝까지 파서 확인하고 뒤로가는 방법은 이미 앞에서 계산한 값을 또 계산해야 하므로 비효율적!
# DP = 꼭대기에서 바닥까지 이어지는 경로 중 거쳐간 숫자의 최대 합 → k번째 레벨에서 현재 노드까지의 최대합으로 분할
# dp[k][i] = k레벨의 i번째 노드의 최댓값!

def solution(triangle):
    h = len(triangle)
    dp = [[0 for _ in range(i+1)] for i in range(h)]  # 초기화

    dp[0][0] = triangle[0][0]

    for k in range(h-1):  # k레벨
        # k레벨의 각 노드에 대해서 왼쪽, 오른쪽 선택
        for i in range(k+1):
            # dp[k][i] 기준으로 대각선 왼쪽 선택
            dp[k+1][i] = max(dp[k][i] + triangle[k+1][i],
                             dp[k+1][i])  # (k레벨의 현재 노드 최댓값 + 왼쪽 노드 값, k+1레벨의 왼쪽 노드의 최댓값)
            # dp[k][i] 기준으로 대각선 오른쪽 선택
            dp[k+1][i+1] = max(dp[k][i] + triangle[k+1][i+1],
                               dp[k+1][i+1])  # (k레벨의 현재 노드 최댓값 + 오른쪽 노드 값, k+1레벨의 오른쪽 노드의 최댓값)

    return max(dp[h-1])
